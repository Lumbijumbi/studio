"""LoliCode script generator for OpenBullet 2."""

from datetime import datetime
from typing import List, Optional
from urllib.parse import urlparse

from .types import (
    LoliCodeConfig,
    SemanticHarEntry,
    DependencyMatrix,
)
from .builders import (
    RequestBlockBuilder,
    KeycheckBlockBuilder,
    ParseBlockBuilder,
)
from .validators import LoliCodeValidator


class LoliCodeGenerator:
    """Generator for LoliCode scripts from HAR analysis."""
    
    def __init__(self, retries: int = 0):
        """
        Initialize the LoliCode generator.
        
        Args:
            retries: Number of retry attempts for generation
        """
        self.request_builder = RequestBlockBuilder()
        self.keycheck_builder = KeycheckBlockBuilder()
        self.parse_builder = ParseBlockBuilder()
        self.validator = LoliCodeValidator()
        self.retries = retries
    
    async def generate(
        self,
        config: LoliCodeConfig,
        entries: List[SemanticHarEntry],
        dependency_matrix: DependencyMatrix
    ) -> str:
        """
        Generate complete LoliCode script.
        
        Args:
            config: Generation configuration
            entries: Filtered HAR entries
            dependency_matrix: Request dependencies
            
        Returns:
            Valid LoliCode script
            
        Raises:
            ValueError: If configuration is invalid
            RuntimeError: If generated script is invalid
        """
        # Validate configuration
        self._validate_config(config, len(entries))
        
        # Sort selected indices by dependency order
        sorted_indices = self._sort_by_dependencies(
            config.selected_indices,
            dependency_matrix
        )
        
        # Generate script sections
        sections: List[str] = []
        
        # Add header comment
        sections.append(self._generate_header())
        
        # Add settings block if provided
        if config.settings:
            sections.append(self._generate_settings(config.settings))
        
        # Generate request blocks
        for index in sorted_indices:
            entry = entries[index]
            request_section = self._generate_request_section(
                entry,
                index,
                config
            )
            sections.append(request_section)
        
        # Add footer
        sections.append(self._generate_footer())
        
        # Join sections
        script = '\n\n'.join(sections)
        
        # Validate generated script
        validation = self.validator.validate(script)
        if not validation.is_valid:
            error_msg = f"Generated invalid LoliCode: {validation.errors[0]}"
            print(f"ERROR: {error_msg}")
            raise RuntimeError(error_msg)
        
        return script
    
    def _validate_config(self, config: LoliCodeConfig, entry_count: int) -> None:
        """
        Validate configuration.
        
        Args:
            config: Configuration to validate
            entry_count: Number of available entries
            
        Raises:
            ValueError: If configuration is invalid
        """
        if not config.selected_indices:
            raise ValueError('INVALID_CONFIG: No requests selected')
        
        for index in config.selected_indices:
            if index < 0 or index >= entry_count:
                raise ValueError(f'INVALID_CONFIG: Invalid index {index}')
    
    def _sort_by_dependencies(
        self,
        indices: List[int],
        matrix: DependencyMatrix
    ) -> List[int]:
        """
        Sort indices by dependency order.
        
        Args:
            indices: Indices to sort
            matrix: Dependency matrix
            
        Returns:
            Sorted indices
        """
        return [i for i in matrix.topological_order if i in indices]
    
    def _generate_header(self) -> str:
        """Generate header comment."""
        return f"""# ═══════════════════════════════════════════════════════════════
# Generated by HAR2LoliCode (Python)
# Date: {datetime.now().astimezone().isoformat()}
# Description: Automated script from HAR analysis
# ═══════════════════════════════════════════════════════════════"""
    
    def _generate_settings(self, settings: dict) -> str:
        """
        Generate settings block.
        
        Args:
            settings: Settings dictionary
            
        Returns:
            Settings block as string
        """
        lines: List[str] = ['SETTINGS']
        
        if settings.get('use_proxy'):
            lines.append('  UseProxy: true')
        
        if 'follow_redirects' in settings:
            lines.append(f'  FollowRedirects: {str(settings["follow_redirects"]).lower()}')
        
        if 'timeout' in settings:
            lines.append(f'  Timeout: {settings["timeout"]}')
        
        if 'retry_count' in settings:
            lines.append(f'  RetryCount: {settings["retry_count"]}')
        
        return '\n'.join(lines)
    
    def _generate_request_section(
        self,
        entry: SemanticHarEntry,
        index: int,
        config: LoliCodeConfig
    ) -> str:
        """
        Generate request section with all blocks.
        
        Args:
            entry: HAR entry
            index: Entry index
            config: Generation configuration
            
        Returns:
            Request section as string
        """
        sections: List[str] = []
        
        # Add section comment
        url_path = urlparse(entry.request.url).path
        sections.append('# ─────────────────────────────────────────────────────────────')
        sections.append(f'# Request {index + 1}: {entry.request.method} {url_path}')
        sections.append('# ─────────────────────────────────────────────────────────────')
        
        # Generate request block
        custom_headers = None
        if config.custom_headers and index in config.custom_headers:
            custom_headers = config.custom_headers[index]
        request_block = self.request_builder.build(entry, custom_headers)
        sections.append(request_block)
        
        # Generate variable extraction if configured
        if config.variable_extractions and index in config.variable_extractions:
            for extraction in config.variable_extractions[index]:
                parse_block = self.parse_builder.build(extraction)
                sections.append(parse_block)
        
        # Generate assertions/keychecks
        if config.custom_assertions and index in config.custom_assertions:
            for assertion in config.custom_assertions[index]:
                keycheck_block = self.keycheck_builder.build(assertion)
                sections.append(keycheck_block)
        else:
            # Default status check
            sections.append(self.keycheck_builder.build_status_check(entry.response.status))
        
        # Add delay between requests
        sections.append('FUNCTION Delay "1000"')
        
        return '\n'.join(sections)
    
    def _generate_footer(self) -> str:
        """Generate footer."""
        return """# ═══════════════════════════════════════════════════════════════
# End of generated script
# ═══════════════════════════════════════════════════════════════"""


async def generate_lolicode(
    config: LoliCodeConfig,
    entries: List[SemanticHarEntry],
    dependency_matrix: DependencyMatrix,
    retries: Optional[int] = None
) -> str:
    """
    Factory function to generate LoliCode.
    
    Args:
        config: Generation configuration
        entries: HAR entries
        dependency_matrix: Dependency matrix
        retries: Optional number of retries
        
    Returns:
        Generated LoliCode script
    """
    generator = LoliCodeGenerator(retries or 0)
    return await generator.generate(config, entries, dependency_matrix)
